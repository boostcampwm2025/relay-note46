# WEEK 02

- 참여자: `J001_강내원`, `J086_김훈기`, `J107_박범한`, `S021_오명진`
- 미션 수행: `J002_강다형`, `J092_노윤지`, `J118_박종원`, `S005_김성훈`

<!-- # 퀘스트 선정 및 가이드라인 -->

## 🔍 Quest1 하루 루틴 프롬프트 작성

#### 배경

부스트캠프의 하루는 생각보다 바쁩니다.  
**"이 모든 걸 단 하나의 프롬프트로 GPT가 부스트캠퍼 맞춤형으로 정리해줄 수는 없을까?"**

#### 목적

`미션정보(해시태그 + 예상 소요 시간) + 하루일정표 + 자신의 배경지식(역량) + 자신이 정한 학습과 구현 밸런스 `만 GPT에게 입력하면,  
하루일정을 한 번에 제시해주는 **"하루 스타터 프롬프트"**를 만든다

#### 달성 기준

프롬프트 성공 기준

* [ ] 나의 기준이 잘 반영되었는가?
* [ ] 수행가능한 현실적인 스케줄이었나?
- [ ] GPT가 제안한 스케줄이 야크털깎기를 막아줬는가?
- [ ] 스케쥴은 명확하게 이해되었는가?
- [ ] 개념 학습에 도움이 되었는가?

---

## 🔍 Quest2 AI로 퀴즈 만들어 복습하기

#### 배경

매일 빠르게 새로운 개념과 기술을 배우고 있지만, 학습한 내용이 정리되지 않은 채 머릿속에서 사라지고 있다면?  
이 퀘스트에서는 지난 주에 작성한 학습정리.md를 기반으로 AI에게 퀴즈를 요청하고, 이를 통해 자신의 이해도를 점검하고 기억을 되살리는 복습 루틴을 만들어본다.  
  
단순히 읽는 복습이 아닌, 질문과 답변을 오가는 퀴즈 형식은 학습 내용을 더욱 능동적으로 떠올리게 도와준다.  
“내가 정말 이해했는가?”를 스스로 점검해보자.  

#### 목적

AI를 활용해 자신만의 복습 퀴즈를 생성하고, 이를 통해 지난 주 학습 내용을 효과적으로 리마인드한다.

정리한 학습 내용을 한 번 더 훑으며 지식을 오래 기억할 수 있도록 만든다.

#### 달성 기준

- [ ] AI를 통해 어제 학습정리.md 내용을 기반으로 맞춤형 퀴즈를 생성했나요?
- [ ] 퀴즈를 피어피드백 때 동료에게 공유하기
- [ ] 퀴즈를 풀면서 모호했던 개념을 다시 정리했나요?

---

## 🔍 Quest3 CS 지식, 마인드맵으로 연결하기

#### 배경

부스트캠프 챌린지 과정의 과제들은 유기적으로 연결되어있습니다.
매일 학습하는 개별적인 컴퓨터 과학(CS) 지식들을 서로 연결하여, 단편적인 암기가 아닌 구조화된 지식 체계를 구축하는 것을 목표로 합니다.

분산된 개념들을 마인드맵으로 시각화하여 지식의 연관성을 파악하고, 이를 통해 기억에 오래 남기고 학습 효과를 극대화하고자 합니다.


#### 목적

AI를 활용하여 학습한 CS 지식들을 연결하는 마인드맵을 생성해주는 프롬프트를 개발하고 적용합니다. 단순히 개념을 나열하는 것이 아니라, 개념 간의 '논리적 유사성'과 '인과 관계'를 중심으로 맵을 구성하도록 AI에 요청하여 숨겨진 연결고리를 찾는 데 도움을 받습니다.

#### 가이드

1. AI 마인드맵 프롬프트 작성 혹은 마인드맵 생성 도구 활용

   - 특정 CS 주제들(예: 캐시, 페이징)을 제시하고, 이들의 공통 원리, 차이점, 상호 영향을 중심으로 마인드맵을 생성하도록 요청하는 재사용 가능한 프롬프트를 만듭니다.
     - 이 형식은 Mermaid.js, Mapify 등 다양한 마인드맵 도구에서 활용할 수 있습니다.
   - 만약 프롬프트 작성이 어렵다면, Mapify와 같은 도구를 사용하여 직접 마인드맵을 생성해도 좋습니다.

2. 마인드맵 생성 및 정리

   - 작성한 프롬프트를 활용하여, 하루하루 학습했던 CS 개념들 중 연결이 될 수 있는 키워드들이 있을 경우 AI에게 연결해 달라고 요청합니다.

   - 생성된 마인드맵(텍스트 또는 이미지)과 핵심 설명을 하나의 마크다운 문서로 깔끔하게 정리합니다.

3. 마인드맵 점검해보기:

   - 마인드맵을 통해 새롭게 발견한 지식의 연결고리는 무엇인지, 이 과정이 기존 학습 방식과 비교하여 어떤 점에서 학습에 더 도움이 되었는지에 대한 간단히 확인해봅니다.

   - 생성한 마인드맵이 개념간의 논리적 흐름을 잘 나타내고 있는지, 그리고 이를 통해 CS 지식이 어떻게 통합적으로 이해되었는지 확인합니다.

#### 달성 기준

- [ ] CS 개념들 간의 논리적 연관성과 인과관계 중심 정리의 필요성을 인지했다
- [ ] CS 개념들을 중심으로, 연결 중심 마인드맵 생성을 지시하는 프롬프트를 작성했다.
- [ ] 마인드맵을 통해 기존에 몰랐던 연결고리를 새롭게 발견했다.
- [ ] 마인드맵이 논리적 흐름과 지식 간 통합성을 잘 표현하고 있는지 검토했다.

---

## 🔍 Quest4 야크 털 깎기 방지 가드레일 치기

#### 배경

> **'야크 털 깎기'(Yak Shaving)**를 방지할 수 있도록 가장 효율적인 프롬프트 형태를 탐색한다.

#### 목적

공부하고자 하는 개념에 대해 집중적인 범위를 설정하여, '야크 털 깎기'(Yak Shaving)를 방지한다

#### 달성 기준

* [ ] 정보를 찾기 전에 AI에게 학습 범위를 확인 받기
* [ ] 시간 관리에 대한 피드백하기

---

# 미션 수행

## J002: **AI로 퀴즈 만들어 복습하기**

- **이유**: 매일 새로운 CS 개념을 배우면서 그날 지식을 습득하기에도 시간이 모자라, 복습이나 개념 정리에 충분한 시간을 확보하기 어려웠다. `AI로 퀴즈 만들어 복습하기` 미션은 기존에 정리한 내용을 기반으로 AI에게 퀴즈를 생성하게 함으로써, 복습을 보다 능동적이고 효율적으로 할 수 있는 방식이라고 느껴졌다. 단순히 정리를 다시 읽는 수동적인 복습이 아니라, 직접 문제를 풀고 모호한 개념을 점검하는 루틴을 만들고 싶어 이 미션을 선택하게 되었다.

<details>
<summary> 릴프 수행 내용 </summary>
  
## 퀴즈
  
### Q1. [객관식] 다음 중 git add 명령을 직접 구현할 때 수행되는 작업 순서로 옳은 것은?
A. SHA-1 해시 계산 → zlib 압축 → 파일 존재 여부 확인 → Blob 생성
B. 파일 내용 읽기 → Blob 생성 → SHA-1 해시 계산 → zlib 압축 후 저장
C. 파일 존재 확인 → zlib 압축 → SHA-1 해시 계산 → Blob 생성
D. git commit을 먼저 실행한 후 add를 수행한다

정답: B

### Q2. [객관식] Git 저장소 내부에서 커밋 객체는 어떤 정보를 포함하고 있는가?
A. 해당 커밋의 작성자, 메시지, 커밋 시간
B. 트리(Tree) 객체의 해시
C. 부모 커밋의 해시 (최초 커밋은 없음)
D. 위의 모든 항목

정답: D

### Q3. [단답형] .git/HEAD 파일의 내용이 ref: refs/heads/main일 때, 이 정보는 무엇을 의미하나요?
정답: 현재 main 브랜치를 가리키고 있음을 의미하며, 브랜치별 커밋 참조 파일은 .git/refs/heads/main에 저장된다.


### Q4. [객관식] Git clone 명령을 직접 구현할 때 .git 디렉토리만 존재해야 하는 이유는 무엇인가?
A. clone이 작동하지 않는 Git 버그 때문
B. 파일 충돌을 방지하기 위해 워킹 디렉토리가 비어 있어야 함
C. Git은 항상 새 디렉토리에서만 동작함
D. HEAD를 찾기 어려워지기 때문

정답: B

## 느낀점
Git 내부 구조에 대해 확실히 이해했다고 생각했는데, 막상 퀴즈 형태로 보니까 순간적으로 헷갈리는 개념이 있어서 놀랐다. 예를 들어, git add 동작 순서나 커밋 객체 안에 포함된 정보는 분명 공부했지만, 선택지 형태로 보니까 머뭇거리게 되는 부분이 있었다.

이번 퀴즈를 통해 단순히 “안다”라고 착각했던 개념들을 점검할 수 있었고, 복습이 훨씬 능동적으로 이루어지는 느낌이었다. 단순히 정리된 내용을 읽는 것보다 직접 문제를 풀고, 헷갈린 개념을 다시 찾아보는 과정이 머릿속에 더 잘 남는 것 같다. 앞으로 다른 CS 개념들을 공부할 때도 이런 방식의 복습 루틴을 만들어 보면 좋겠다는 생각이 들었다.

  
</details>

## J092: **하루 루틴 프롬프트 작성**

- 이유: 미션을 진행하며 시간 관리의 중요성을 절실히 느꼈고, 계획 없이 하루를 보내는 날이 잦았다. 효율적인 몰입을 위해 나만의 루틴을 설정하고 이를 기반으로 하루 스케줄을 체계적으로 관리해보고자 한다.

<details>
<summary> 릴프 수행 내용 </summary>
  
## 하루 루틴 프롬프트 작성

### 프롬프트
```
🧠 하루 스타터 프롬프트
- 지금 시간은 {{시작시간}}이고 나는 {{취침시간}}까지 작업할 예정이야
- 미션은 {{미션 설명}}이고, 학습 키워드는 {{학습 키워드}}야
- 내 방식은 학습은 단단히 한 뒤, 설계/구현은 애자일하게 반복하며 완성하는 흐름이 좋아
- 내 특징은 learning by doing을 중요하게 생각하고, 머메이드로 구조도 그리는 걸 좋아해
- 이걸 기반으로 오늘 하루를 시간대별로 나눠서 계획 짜줘. 스트레칭 시간과 회고 포인트도 함께!
```

### 결과
|시간|할 일|목적/성과|
|---|---|---|
|14:30~14:45|**오늘 목표 재정비 + 리듬 설정**|- 목표 확인, 마음가짐 다지기- 리드미에 오늘 목표 작성|
|14:45~15:30|**학습 ① 비동기 이벤트의 철학, setTimeout vs setImmediate 등**|- 이벤트 큐 / 루프의 흐름 체계화- 단순 호출 vs 메시징 방식 구분|
|15:30~16:30|**학습 ② 병렬 처리 구조와 EventEmitter 설계 사례**|- Node.js에서 비동기 시스템을 어떻게 구성할지 감 잡기|
|16:30~17:00|**학습 ③ 객체지향 데이터 흐름 정리 & 머메이드로 구조도 그리기**|- 모듈 간 메시지 흐름 시각화- 책임 분리 아이디어 도출|
|17:00~17:30|**학습 정리 및 체크포인트 작성**|- 배운 내용을 미션 요구사항에 연결- 구현 목표 뽑아내기|
|17:30~18:30|**설계 시작: 최소한의 흐름 설계 + 이벤트 흐름 스케치**|- 큐, 매니저, 모듈 구성- 대기 상태, 처리 시작/종료의 시점 명확화|
|18:30~19:30|🍽 **저녁 식사 + 가벼운 산책 또는 뇌 리셋**|- 장기 집중을 위한 리프레시|
|19:30~21:00|**1차 구현: 등록 -> 큐 -> 변환 모듈 흐름 구현 + 콘솔 출력**|- EventEmitter / setTimeout 활용- 상태 변화 로그 찍기|
|21:00~22:00|**2차 구현: 변환 -> 검증 흐름 구현**|- 한 번에 하나만 처리하는 구조 시뮬레이션- 큐 동작 검증|
|22:00~22:30|**현황판 구현 + 고객별 상태 출력 구현**|- DashBoard 역할 설계 및 상태 추적|
|22:30~23:00|**테스트: 시나리오 입력 값에 따라 동작 확인 + 버그 수정**|- 비동기 흐름 꼬임 방지- 시각화 로그 보강|
|23:00~23:30|**리드미 작성 (설계 배경, 흐름도, 사용법)**|- 깃허브 공유 기준 리드미 정리|
|23:30~00:30|**정리 및 부족한 구현 + 가벼운 리팩터링**|- 분리 안된 로직 나누기- 이벤트 이름 의미 있게 명명|
|00:30~01:30|**회고 + 학습 내용 미션에 써먹기 정리**|- 학습한 키워드가 어디에 적용됐는지 쓰기- 배운 점 정리|
|01:30~02:00|**정리 마무리 + 수면 준비 루틴**|- 브라우저 탭 닫기- 내일 해야 할 것 생각해두기|

### 느낀점
- 원래 자세하게 계획을 짜지 않아서 계획표가 있으니까 조금 부담?도 됐던 것 같다. 그래도 전체적인 가이드를 잡고 미션을 진행할 수 있어서 의미 있었다.

</details>

## J118: **AI로 퀴즈 만들어 복습하기**

- 선택이유: 매일 새로운 학습 목표를 세우고 이를 달성하며 CS 지식을 꾸준히 학습하고 정리하고 있다. 깊이 있게 이해하며 학습하고자 하지만, 다음 날 또 새로운 내용을 배우느라 복습할 시간이 부족하다고 느꼈다. 퀘스트를 통해 ai로 퀴즈를 만들고 복습할 수 있다면, 이전에 배운 내용을 상기하고 내 것으로 만들 수 있을 것 같다.
  
<details>

<summary> 퀴즈 수행 내용 </summary>

## Day13 미션 퀴즈

### **1. git add 명령어가 실제로 하는 일은 무엇인가요?**

**a)** 파일을 리포지토리에 즉시 커밋한다

**b)** 파일을 .gitignore에 추가한다

**c)** 파일을 staging 영역(index)에 등록한다

**d)** 로컬 저장소를 원격 저장소와 동기화한다

💡 **정답: c**

> git add는 워킹 디렉토리에서 변경된 파일을 staging 영역(즉, index)에 등록하여, 다음 커밋에 포함되도록 준비시킨다. 실제 커밋은 git commit 명령어로 이루어진다.
> 

---

### **2. Git의 index 파일은 어떤 정보를 담고 있나요?**

**객관식 보기**

**a)** 저장소의 커밋 메시지 목록

**b)** 스테이징된 파일들의 메타데이터와 blob 해시

**c)** 브랜치 목록과 리모트 URL

**d)** 이전 커밋의 부모 해시 정보

💡 **정답: b**

> Git의 **index** 파일은 staging 영역의 스냅샷을 저장하는 바이너리 파일이다.내부에는 스테이징된 파일의 **경로**, **퍼미션 정보**, **파일 크기**, **수정 시간**, 그리고 **blob 객체의 SHA-1 해시**가 담겨 있다.이 정보를 바탕으로 Git은 정확한 커밋 내용을 구성할 수 있다.
> 

---

### **3. Git에서 blob 객체는 어떤 역할을 하나요?**

**a)** 파일의 디렉토리 구조를 저장한다

**b)** 브랜치 이름을 저장한다

**c)** 실제 파일의 내용을 저장한다

**d)** 커밋 메시지를 저장한다

💡 **정답: c**

> blob은 Git이 파일 내용을 저장하는 방식이다. 각 파일의 내용은 blob 객체로 변환되어 .git/objects에 저장되며, 동일한 내용의 파일은 동일한 blob 해시를 갖는다.
> 

---

### **4. Git의 .git/objects 디렉토리에 저장된 파일 경로는 어떻게 구성되나요?**

**a)** 파일 이름을 알파벳순으로 정렬하여 경로로 사용

**b)** 커밋 메시지의 일부를 디렉토리 이름으로 사용

**c)** SHA-1 해시의 앞 2자리를 디렉토리, 나머지를 파일명으로 사용

**d)** 파일 크기와 확장자에 따라 자동으로 배치됨

💡 **정답: c**

> 예를 들어, SHA-1 해시가 b6fc4c...라면 objects/b6/fc4c... 형태로 저장된다. 이는 파일 수가 많아질 경우 성능을 높이기 위한 Git의 설계이다.
> 

---

### **5. Git에서 staging 영역(index)은 언제 사용되며, 어떤 동작 이후 내용이 반영되나요?**

**a)** 파일을 삭제한 직후 바로 반영됨

**b)** git add 명령으로 index에 반영되며, 이후 git commit 시 커밋에 포함됨

**c)** git push를 수행하면 index가 자동으로 업데이트됨

**d)** 워킹 디렉토리에서 파일을 수정하면 자동으로 갱신됨

💡 **정답: b**

> staging 영역은 git add로 파일을 등록하면 갱신되며, 커밋 시 그 스냅샷이 기준이 된다. Git은 워킹 디렉토리 → index → 커밋으로 흐름이 구성된다.

## 느낀점

미션 수행 다음날 가볍게 수행했지만 생각보다 주요내용에 대한 복습이 된다는 것을 체감할 수 있었다..!

</details>

## S005: **AI로 퀴즈 만들어 복습하기**

- 선택이유: AI를 활용하여 맞춤형 퀴즈가 반복 학습을 쉽게 도와주므로 미션을 해결하면서 모호했던 개념을 점검하고 자신의 구멍을 발견하기에 적합하다고 생각했다. 그리고 피어 피드백이나 슬랙에서 공유가 가능하므로 서로의 학습 상황을 점검하고 동기부여가 될거 같았다.
- 후기: 미션 내용과 학습정리를 바탕으로 퀴즈를 풀어보니 다시 한번 개념을 정리할 수 있었다. 간단한 퀴즈였지만 핵심을 짚어주는 구조여서 기억에 오래 남았고, 앞으로도 학습을 한 후에 퀴즈나 문제로 정리해보는 습관을 들이면 좋을 것 같다는 생각이 들었다.

<details>

<summary> 퀴즈 수행 내용 </summary>

## 🧠 월요일 CS 복습 퀴즈

### Q1.

Q. DispatchQueue(label: "com.example.myQueue")로 생성된 큐의 기본 특성은?

A. 전역(Global) 병렬 큐
B. 사용자 정의 병렬 큐
C. 직렬(Serial) 큐
D. 메인 큐(Main Queue)

정답: C — `DispatchQueue(label:)`은 기본적으로 직렬 큐를 생성함.

### Q2.

Q. 이벤트 큐(Event Queue)의 주된 역할은?

A. 이벤트를 즉시 실행해 병목을 줄임
B. 이벤트를 무작위 순서로 분산 처리함
C. 이벤트를 순차적으로 저장하고 처리 흐름을 제어함
D. 이벤트 간 충돌을 막기 위해 동시에 처리함

정답: C — FIFO(First-In First-Out) 방식으로 비동기 이벤트 흐름을 제어함.

### Q3.

Q. 다음 중 OperationQueue가 GCD와 다른 고유의 기능은 무엇인가?

A. 스레드 풀에 작업을 넣는 기능
B. 작업의 우선순위와 의존성 설정
C. 병렬 처리를 지원
D. 백그라운드에서 작업 실행


정답: B — `OperationQueue`는 작업 간 우선순위 및 의존성 설정이 가능함.

### Q4.

Q. GCD에서 스레드 풀(Thread Pool)을 사용하는 주된 이유는?

A. 스레드마다 새로운 메모리를 할당하기 위해
B. 비동기 작업을 직렬로 만들기 위해
C. 스레드 생성 비용을 줄이고, 재사용으로 효율을 높이기 위해
D. UI 업데이트를 쉽게 하기 위해

정답: C — GCD는 시스템 제공 스레드 풀을 활용해 비용을 줄이고 효율적으로 스케줄링함.

### Q5.

Q. Swift에서 DispatchQueue.global().async로 코드를 실행하면 발생하는 현상으로 올바른 것은?

A. 코드는 즉시 실행되며 동기적으로 블로킹된다
B. 작업은 새로운 스레드를 생성해 메인 스레드에서 실행된다
C. 작업은 비동기로 백그라운드 스레드에서 실행된다
D. 메모리는 자동 해제되지 않는다

정답: C — `.async`는 비동기로 백그라운드 스레드에서 실행되며 메인 스레드를 블로킹하지 않음.



## 🧠 수요일 CS 복습 퀴즈

### Q1.

Git에서 커밋 해시는 어떤 데이터를 해싱한 결과로 생성되는가?

A. 커밋 메시지만
B. 커밋 메시지와 타임스탬프만
C. commit <size>\0<커밋 내용> 전체 바이트
D. 트리 해시, 부모 해시만

정답: C


### Q2.

mit에서 커밋 로그(mit log)에 출력되는 해시와 mit commit으로 저장된 커밋 해시는, 동일한 커밋이라면 항상 같아야 한다.

정답: O
(단, 같은 데이터로 해시를 계산했을 경우에만 동일함)


### Q3.

다음 중 블랙박스 테스트(Black-box Testing)의 가장 핵심적인 특징은?

A. 내부 구현을 보고 테스트 케이스를 작성한다.
B. 성능 프로파일링을 포함한다.
C. 외부 동작과 입력/출력만으로 테스트한다.
D. 테스트 커버리지를 분석한다.

정답: C


### Q4.

LogManager.appendLog에서 커밋 해시가 실제 저장된 해시와 달랐다면, 가장 가능성 높은 원인은 “toGitFormat()”의 누락된 사용이다.

정답: O


### Q5.

다음 중 테스트 용이성을 높이기 위한 전략으로 가장 알맞은 것은?

A. 모든 클래스를 final로 선언한다.
B. 의존 객체를 직접 생성하여 사용한다.
C. 객체 간 의존성을 인터페이스(프로토콜)로 추상화한다.
D. 파일 시스템에 바로 접근한다.

정답: C

## 느낀점

미션 수행 다음날 가볍게 수행했지만 생각보다 주요내용에 대한 복습이 된다는 것을 체감할 수 있었다..!
</details>
