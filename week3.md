# 📌 릴레이 프로젝트 회의록

### 👥 3주차 릴레이 프로젝트 그룹

`J010_강성준` `J015_고범석` `J100_문예찬` `S031_정명곤`

## 🎯 회의 목적

팀에서 진행한 릴레이 프로젝트의 레포지토리를 이어받아 README.md 내용을 분석하고 개선 및 퀘스트 수정 방안을 논의

### 📌 그룹원별 이전 릴레이 프로젝트 진행 방법 공유

1. 이전 레포지토리의 `README.md` 내용을 숙지하고 주제를 선정함

2. 선정된 주제에 대한 조사 수행

- 키워드를 직접 사용해보며 실용성 확인
- 키워드가 실현 가능한지 구체적으로 조사

### 📌 퀘스트 수행 후기 공유

1️⃣ 퀘스트 성격

- 퀘스트가 '일'처럼 느껴질 경우 흥미가 떨어지고 동기 부여가 어려워짐
- 아무리 사소한 퀘스트라도 부담감을 느낄 수 있음

2️⃣ **이해 확인 방법**

- 퀘스트 수행 과정에서 이해 여부를 퀴즈나 역질문 방식으로 점검하는 것이 효과적
- 이전 대화를 참고한 질문을 통해 확실한 이해 도달 가능

3️⃣ **퀘스트 난이도**

- 지나치게 가벼운 퀘스트는 AI를 활용하면서 얻는 인사이트가 적음

### 🤔  퀘스트별 상세 피드백 및 개선 제안

**🟡 Quest1:** 하루 루틴 프롬프트 작성

**개선 방향**

- 자신의 지식을 점검하는 방식으로 목적 변경
- JK님의 의견 참고하여 "내가 아는 것"과 "안다고 착각하는 것"을 구분하는 방식으로 퀘스트 개편

**🟢 Quest2: AI를 활용한 퀴즈 제작 및 복습**
**개선 방향**

- 퀴즈 형태의 복습 방식 유지
- 학습 중 본인이 중요하다고 판단한 키워드 중심으로 확인하는 방안
- 질문-답변 방식으로 학습 점검 강화

🔵 **Quest3: CS 지식을 마인드맵으로 연결**
**개선 방향**

- 퀘스트 전면 개편하여 회고를 AI가 돕는 형식으로 변경
- 자신의 생각과 감정을 AI가 정리하고 분위기나 형식을 다양화해 회고의 문턱을 낮추는 방안 도입

🔴 **Quest4: 야크 털 깎기 방지 가드레일 설정**
**개선 방향**

- **프롬프트 활용 역량 강화**
  - AI 피어세션에서 다양한 프롬프트 사용 및 비교
  - 상황별 프롬프트 최적화 연습 (예: 학습, 코드 리뷰, 문제 해결 등)
- **AI 활용 회고 작성** → 선택
  - AI 사용 경험을 간단히 회고
  - 자신이 AI를 어떻게 사용했는지 점검하고 발전 방향 탐색

### 📌 결론 및 추가 제안사항

- AI 활용 방법에 대한 실습과 회고를 도입해 퀘스트의 실질적 학습 효과를 생각해보기
- 구체적이고 명료한 방향으로 퀘스트 개선해 참가자들의 흥미와 효율성 동시 확보

## 📖 3주차 퀘스트 목록

### 🔍 Q1. 학습전 배경지식 점검하기

🚀 **배경**

- 기존 퀘스트(하루 루틴 프롬프트 작성)에서 자신의 지식을 점검하는 방식으로 목적 변경
- 미션을 진행하기 위해 내가 아는 것과 알아야 하는 것을 구분하기 위해 만드는 것으로 변경하는 것이 좋을 것 같다.
- JK님이 말씀하신 주의점에 따라 내가 아는 것과 안다고 착각하는 것을 확인할 수 있다.

🎯 **목적**

- 미션의 학습 키워드에 대한 질문을 AI에게 만들어달라 요청한 후 내가 실제로 그 지식을 알고 있는지 확인해본다.
- 이를 토대로 내가 학습할 범위를 확인하고 학습할 방향성을 설계해본다.(`체크포인트`에 반영)

💡 **달성 기준**

- [ ] 학습키워드에 대한 질문에 직접 답을 적어본다.
- [ ] 내가 모르는 부분을 확인한 후 `체크포인트.md`에 작성한다.
- [ ] 체크포인트에 작성한 부분을 학습하고 `학습정리.md` 에 추가한다.

### 🔍 Q2. **AI로 퀴즈, 질문 만들어 학습 도우미로 사용하기**

🚀 **배경**

- `학습정리.md` 를 다 넘겨주는 건 이미 학습을 다 마친 후라 학습 범위가 너무 넓어질 것 같다.
- **_학습하는 중_** 에 자신이 제대로 이해하고 있는지 확인하고 싶다.

🎯 **목적**

- 학습과정 중 이해가 안가는 부분에 대해서 간단한 퀴즈와 질문을 통해 현재 이해도를 점검후 이해를 높인다.

💡 **달성 기준**

- [ ] 내가 학습하는 내용에 대해 이해가 안가는 키워드를 추출해본다.
- [ ] 추출한 키워드를 통해서 AI를 통해 퀴즈, 질문을 만들어보기
- [ ] 만든 퀴즈를 직접 풀면서 이해도를 높이기
- [ ] 이해한 내용을 바탕으로 다시 한번 학습 방향성 점검해보기
- [ ] 만든 퀴즈 내용을 슬랙에 공유해 다른 캠퍼들과의 의견 및 경험 공유해보기 (선택)

### 🔍 Q3. 회고시 AI를 활용해보기

🚀 **배경**

- 요즘 슬랙에 매일매일 회고를 남기는 캠퍼들이 많아지고 있다.
- 자신의 생각이나 감정을 글로 남기는데 어려움을 겪는 캠퍼들이 있을 수 있다.

🎯 **목적**

- AI를 통해서 자신의 생각, 감정을 글로 남기는 문턱을 낮추어보자.
- 회고를 남기고 싶지만 스스로 생각이나 감정을 정리를 하기 어려울 때 AI에게 자신의 생각과 감정을 솔직하게 생각나는대로 이야기하고 이것을 정리하도록 해준다.
- 회고작성시 자신이 원하는 무드(ex: 즐거운 분위기의 회고, 감성적인 분위기, 진지한 분위기)를 선택해서 회고로 만들어보기

💡 **달성 기준**

- [ ] 정말로 회고를 남기고 싶은 지 스스로 생각해보기.
- [ ] 일주일에 한 번 이상 슬랙에 자신의 회고 내용을 공유해본다.

### 🔍 Q4. AI 사용에 대한 회고

🚀 **배경**

- 스스로 AI를 어느정도까지 활용을 해야하는지에 대한 고민이 있는 캠퍼들이 많다.
  - 어느 목적으로 사용해야 하는지, 그렇다면 어느 정도까지 요청을 해야하는지?

🎯 **목적**

- 스스로 AI를 어떻게 사용했는지 돌아보며 더욱 나은 AI 활용에 대해 찾아볼 수 있다.
- 앞으로 어떻게 AI를 활용할지에 대한 점을 정리해 더 좋은 개발자로 성장하기

💡 **달성 기준**

- [ ] 스스로 AI를 어떻게 사용했는지를 돌아보기
  - 좋았던 점, 사용했을 때 별로였던 점등 생각해보기
- [ ] 회고 작성시 AI 사용 금지.
- [ ] 앞으로 AI를 활용하면 더 좋을지 고민후 정리해보기.

---

## 🎮 미션 선택

- **J074\_김재민: Q1. 학습전 배경지식 점검하기** ✅

  **이유**

  항상 스스로 ai를 통해 공부해 오면서, ai가 알려주는 지식을 습득하며, '스쳐 지나가는 지식으로 습득하는 건 아닐까?' 불안함을 가지고 있었습니다. 제가 평소 메타인지를 중요시 여겨서 '내가 알고있는 것, 모르는 것' 구분하는 것을 확실히 하고, 그것을 점검하기를 즐겨 합니다. 따라서 주어진 퀘스트 1이 제 학습습관과 일치하여 퀘스트로 선정했습니다.

<details>
<summary>🚀수행한 퀘스트 펼쳐 보기/닫기</summary>
<div markdown="1">
__미션을 어느 정도 파악한 지금, 개선하기를 진행하며 내가 전반적인 미션의 흐름과 배경지식을 잘 알고 있는 건가? 확인하는 단계로 ai를 사용해보았습니다.__

이 프로젝트의 목표와 요구사항을 잘 정리해 주셨군요. 앞으로 이 학습 목표에 맞춰 제가 답변해 드릴 수 있도록 준비하겠습니다.
말씀하신 학습 키워드와 미션의 난이도를 보면, 단순히 코드를 작성하는 것을 넘어 네트워크 통신의 본질을 이해하고, 그 위에 복잡한 애플리케이션 로직을 설계하는 능력을 요구하는 미션인 것 같습니다.
어떤 개념이 궁금하신가요? 제가 답해드릴 수 있도록 자유롭게 질문해 주세요. 예를 들어 다음과 같은 질문으로 시작할 수 있습니다.

"TCP와 UDP의 차이를 다시 한번 간단하게 설명해 줄 수 있어?"

"HTTP 규격을 비슷하게 만들라는 게 정확히 무슨 의미야?"

"JSON으로 요청/응답 메시지를 주고받으려면 클라이언트와 서버에서 어떻게 구현해야 해?"

"login:S001 같은 메시지 형식을 JSON으로 바꾸려면 어떻게 해야 할까?"

언제든지 질문해 주세요. 함께 미션을 해결해 나가겠습니다!

1. TCP는 client와의 연결을 확실하게 하여 손실 없고, 순차적으로, 트랜잭션?이 보장되도록 한다. TCP는 3-way-handshake를 통해 확실한 연결 상태를 확인하며 여러 섹션으로 나누어 여러 패킷?으로 이루어져있다. 연결 해제시에는 4-way-handshake를 통해서 확실한 연결해제.
   UDP는 기관총처럼 데이터를 뿌릴 수 있는, 최대한 빠른 시간에 데이터를 보내는 형식. 연결상태를 점검하지 않고 그냥 보내서 실시간 데이터에 쓰일 수 있다. 멀티캐스팅, 브로드캐스팅을 지원한다.
2. HTTP란 hyper text transmission protocol로 프로토콜의 규격을 정한 것이며, 서버와 client간 request, response으로 이루어져 있어. HTTP규격이라 함은 request와 response의 형태를 지키며 통신하라는 것 같아. request는 header와 content, body등으로 이루어져 있고, response는 header, status code, content로 이루어져 있어.
3. json으로 요청/응답메세지를 2번의 규격을 구현할 수 있지. 예를 들어, request의 경우, {header:...,content:{cookie:...,session:...}}, response의 경우 {header:...,status code : 200, ...}
4. {GET : Login, S001}이런식으로?
   안녕하세요! 말씀해주신 내용들을 하나씩 살펴보며 정확하게 이해했는지 확인하고, 미션에 대한 추가적인 조언을 드릴게요. 정말 중요한 내용들을 정확하게 짚어주셨습니다.

5. TCP와 UDP에 대한 이해
   매우 정확하게 이해하셨습니다. 💯

TCP: 3-way-handshake를 통한 연결 설정, 4-way-handshake를 통한 연결 해제, 패킷의 순차적 전송, 오류 검출 및 재전송 등을 통해 신뢰성을 보장하는 프로토콜입니다. 트랜잭션이라는 표현도 적절해요. 한 번에 주고받는 일련의 작업이 완전하게 수행되도록 보장하는 것이 트랜잭션인데, TCP가 바로 그런 신뢰성 있는 통신을 담당합니다.

UDP: 연결 과정 없이 데이터를 빠르게 전송하는 비연결성 프로토콜이라는 점도 정확합니다. 주로 실시간 스트리밍, DNS, 그리고 말씀하신 브로드캐스트나 멀티캐스트에 사용되는 것도 맞습니다.

이번 미션에서는 net 모듈을 통해 TCP와 UDP의 이런 특징을 직접 구현하는 것이 목표입니다. TCP로는 고객 및 MD의 로그인, 상품 구매 등 신뢰성이 중요한 기능을 구현하고, UDP로는 브로드캐스트와 같이 빠르게 메시지를 전달하는 기능을 구현해야겠죠.

2. HTTP 규격 및 메시지 구조에 대한 이해
   이해하고 있는 방향이 맞습니다. 훌륭해요!
   HTTP는 서버와 클라이언트 간의 약속된 메시지 형식(프로토콜)입니다. 이번 미션에서 "HTTP 규격을 비슷하게 만들라"는 것은, HTTP처럼 요청과 응답의 형식을 미리 정의하라는 의미로 해석할 수 있어요.
   HTTP의 헤더(Header)에는 요청/응답의 메타 정보(예: Content-Type, Content-Length)가 담기고, 바디(Body)에는 실제 데이터가 담기죠. 이것처럼 당신의 애플리케이션에서도 메시지의 종류(로그인, 구매 등)와 실제 데이터(캠퍼ID, 상품정보 등)를 구분해서 보낼 수 있는 구조를 직접 만들어야 합니다.

3. JSON을 활용한 메시지 구조
   예시가 매우 좋습니다.
   말씀하신 { header: ..., content: { ... } }와 같은 JSON 구조는 HTTP의 헤더와 바디 개념을 잘 녹여낸 훌륭한 예시입니다.
   예를 들어, login 요청을 JSON으로 만든다면 다음과 같은 형태가 될 수 있습니다.
   JSON

{
"request_type": "login",
"data": {
"campId": "S001"
}
}
응답은 이렇게 만들 수 있겠죠.
JSON

{
"response_type": "login_success",
"status_code": 200,
"data": {
"groupId": 1
}
}
이런 구조를 미리 약속하고, 클라이언트와 서버가 서로 이 구조에 맞춰 메시지를 주고받으면 깔끔하게 통신 로직을 구현할 수 있습니다.

4. login:S001을 JSON으로 바꾸는 법
   "{GET: Login, S001}"이라는 아이디어 좋습니다!
   이 형태는 HTTP의 GET /login/S001 같은 REST API 형식을 연상하게 하는 좋은 접근법입니다. 다만 JSON은 key: value 쌍으로 이루어져 있으므로, 정확히는 다음과 같은 형태가 될 수 있습니다.
   JSON

{
"command": "login",
"campId": "S001"
}
물론, 이것은 단지 한 가지 예시일 뿐이며, 팀원들과 상의해서 더 좋은 구조를 만들어도 됩니다. 중요한 것은 클라이언트와 서버가 메시지 구조에 대해 합의하는 것입니다.

앞으로의 학습 및 미션 진행에 대한 조언
말씀해주신 내용들을 보면 이미 미션의 핵심을 정확히 파악하고 계세요. 앞으로는 이 지식들을 바탕으로 실제 코드로 구현하는 과정에 집중하시면 됩니다.
다음과 같은 부분을 생각해 보시면 미션 해결에 도움이 될 거예요.

메시지 파서(Parser) 구현: 클라이언트와 서버가 주고받는 메시지(예: login:S001)를 JSON 객체로 변환하고, 다시 JSON 객체를 메시지 문자열로 변환하는 함수를 만들어 보세요.

TCP 메시지 경계 처리: TCP는 스트림 방식이므로, socket.on('data', ...) 이벤트가 한 번에 완전한 메시지를 전달하지 않을 수도 있다는 점을 고려해야 합니다. 여러 조각으로 나누어 들어오는 메시지를 하나의 완전한 메시지로 합치는 로직이 필요할 수 있어요.

세션(Session) 관리: 로그인한 클라이언트를 식별하고, 해당 클라이언트의 상태(예: 로그인 여부, 그룹 ID)를 저장하는 구조를 설계해야 합니다.

어떤 부분에 대해 더 자세히 알아보고 싶으신가요? 예를 들어, "TCP 메시지 경계 처리"에 대해 질문해 주시면 제가 자세히 설명해 드릴게요.
더 필요한 배경지식에 대해서 물어봐줘
알겠습니다! 미션을 성공적으로 해결하기 위해 알아두면 좋은 추가적인 배경지식들을 질문 형식으로 제시해 드릴게요. 이 질문들에 답해보면서 미션의 복잡한 요구사항들을 어떻게 해결해 나갈지 구체적인 그림을 그려볼 수 있을 거예요.

1. TCP 스트림과 메시지 경계 처리
   질문: TCP는 스트림 방식으로 데이터를 전달하기 때문에, 클라이언트가 buy #1, 5와 logout을 연달아 보냈을 때, 서버는 이 두 메시지를 한 번에 buy #1, 5logout으로 받거나, buy #1과 , 5logout처럼 나누어 받을 수도 있습니다. 이 문제를 어떻게 해결해야 할까요?

힌트: HTTP는 Content-Length 헤더를 사용해서 메시지의 끝을 알려줍니다. 우리만의 프로토콜에서는 이와 비슷한 역할을 하는 메시지 구조를 어떻게 설계할 수 있을까요?

2. 동시성 및 세션 관리
   질문: 서버는 여러 클라이언트가 동시에 접속할 수 있어야 합니다. 각 클라이언트의 socket 객체는 고유하지만, 이 socket 객체와 로그인한 campId, groupId 같은 세션 정보를 어떻게 연결해서 관리할 수 있을까요?

힌트: 서버의 전역 변수나 객체에 campId를 키(key)로, socket 객체를 값(value)으로 저장하는 방식도 가능합니다. 하지만 클라이언트가 연결을 끊었을 때 이 정보를 어떻게 삭제해야 할까요?

3. UDP 브로드캐스트의 범위와 구현
   질문: 요구사항에 "UDP 방식으로 실행 중인 모든 고객 클라이언트에게 브로드캐스트"하라고 되어 있습니다. 255.255.255.255를 사용해서 브로드캐스트를 구현할 때, 실제 로컬 네트워크를 넘어 다른 네트워크에 있는 클라이언트에게도 메시지가 전달될까요? 그리고 UDP 브로드캐스트 메시지를 특정 포트에서 받으려면 클라이언트는 어떻게 준비해야 할까요?

힌트: UDP 브로드캐스트는 라우터를 통과하지 못하는 특징이 있습니다. 클라이언트 측에서는 bind() 메서드를 사용해서 특정 포트에서 메시지 수신 대기를 시작해야 합니다.

4. MD 클라이언트 인증(Authentication)과 보안
   질문: MD 클라이언트는 서버에 접속할 때 "주어진 토큰"을 함께 보내서 인증해야 한다고 되어 있습니다. "서버와 클라이언트만 알고 있는 해시 함수를 활용"하는 방식은 어떻게 구현할 수 있을까요?

힌트: 클라이언트와 서버가 미리 약속된 비밀키(Secret Key)를 공유하고, 클라이언트가 보낸 메시지와 이 비밀키를 조합해서 해시 값을 생성하는 방식이 있습니다. 서버는 같은 방식으로 해시 값을 만들어 클라이언트가 보낸 값과 비교하여 인증할 수 있습니다.

5. 그룹 관리와 메시지 전달 로직
   질문: snapchat 요청을 받은 서버는 "같은 쇼핑 그룹에 있는 사람들과 스냅채팅"을 할 수 있게 해야 합니다. GroupManager 클래스를 활용해서, 특정 그룹에 속한 모든 멤버에게만 메시지를 보내는 로직을 어떻게 구현할 수 있을까요?

힌트: GroupManager의 getGroupMembers(groupId) 메서드를 사용해서 그룹에 속한 모든 campId를 가져올 수 있습니다. 그리고 이 campId를 기반으로 해당 클라이언트의 socket 객체를 찾아 메시지를 전송해야 합니다. 이를 위해 앞서 다룬 세션 관리 로직이 필요합니다.

1. 잘 모르겠네. 너말대로 content-length로 데이터 전송의 시작과 끝을 알려야 겠네
2. 세션 DB 혹은 메모리 상의 세션 storage를 만들어서 너가 말한대로 key value로 campId, socket 객체 값을 저장을 하고, 연결을 하거나 연결을 끊었을 때 storage 업데이트 하면 될듯
3. UDP 브로드캐스트는 라우터를 통과하지 못하는 특징은 몰랐네. 너가 말한대로 UDP dgram으로 binding을 통해 서버측에서 브로드캐스트 하는 것을 리스닝시켜야겠네.
   당신의 답변들을 보니 미션의 핵심을 아주 잘 이해하고 계시네요! 특히 TCP와 UDP의 특징, 그리고 JSON을 활용한 메시지 구조에 대한 이해가 매우 훌륭합니다.
   제가 드린 질문들에 대한 답변을 정리하고, 미션에 대한 추가적인 팁을 드릴게요.

4. TCP 메시지 경계 처리
   Content-Length와 같은 방식으로 해결하겠다는 아이디어는 아주 정확합니다. 이는 **메시지 프레이밍(Message Framing)**이라고 불리는 중요한 개념이에요.
   가장 간단한 방법은 메시지의 끝을 나타내는 **특정 구분자(Delimiter)**를 사용하는 것입니다. 예를 들어, 모든 메시지 끝에 \n (줄바꿈 문자)을 붙이는 거죠.

// 클라이언트가 보내는 데이터
login:S001\n
buy:{"id":1, "count":5}\n
서버는 socket.on('data', ...) 이벤트가 발생할 때마다 수신된 데이터를 버퍼에 계속 쌓아두고, \n 문자가 나타날 때마다 버퍼에서 하나의 완전한 메시지를 잘라내서 처리하면 됩니다.

2. 세션 관리
   세션 storage를 만들어 campId와 socket 객체를 매핑하겠다는 계획은 완벽합니다.

연결 시: login 요청을 받으면 campId를 키로, socket 객체를 값으로 세션 스토리지에 저장합니다.

연결 끊김 시: socket.on('end', ...)나 socket.on('close', ...) 이벤트 핸들러에서 해당 socket을 세션 스토리지에서 찾아 삭제하면 됩니다.

이러한 세션 관리는 snapchat 요청 시 같은 그룹 멤버에게만 메시지를 보내거나, logout 요청 시 특정 클라이언트를 그룹에서 제거하는 등, 미션의 복잡한 요구사항들을 처리하는 데 필수적입니다.

3. UDP 브로드캐스트 구현
   라우터를 통과하지 못하는 점까지 정확하게 파악하셨네요. UDP 브로드캐스트의 범위는 동일 네트워크 세그먼트로 제한됩니다.
   요구사항을 만족하려면 다음과 같이 구현하면 됩니다.

MD 클라이언트: UDP를 통해 브로드캐스트 메시지를 보냅니다.

고객 클라이언트: UDP 소켓을 생성하고, 서버와 같은 포트 번호로 bind하여 브로드캐스트 메시지를 수신 대기해야 합니다.

dgram 모듈의 setBroadcast(true) 메서드를 사용하면 브로드캐스트 주소로 메시지를 보낼 수 있습니다. 이 기능을 활용하여 MD 클라이언트의 요구사항을 해결할 수 있습니다.

미션 성공을 위한 마지막 팁
당신이 이미 알고 있는 지식들을 바탕으로 미션 코드를 구현할 때, 다음 두 가지를 더 염두에 두면 좋습니다.

객체 지향 설계: groupManager, productManager, chatManager와 같은 클래스들을 잘 활용하여 코드를 구조화하면, 각 기능이 독립적으로 동작하고 유지보수가 쉬워집니다.

비동기 입력 처리: 클라이언트에서는 사용자의 입력(login S001, buy #1, 5)을 받고, 동시에 서버로부터의 메시지(login success, broadcast)를 받아 출력해야 합니다. readline 모듈과 socket.on 이벤트 핸들러를 함께 사용해서 비동기적으로 처리하는 구조가 필요합니다.

언제든지 궁금한 점이 생기면 다시 질문해 주세요. 당신의 미션 해결을 응원합니다!
또 배경지식에 대해서 물어봐줘
훌륭합니다. 미션에 대한 이해도를 더 높일 수 있는 배경지식들을 질문 형식으로 다시 제시해 드릴게요. 이 질문들에 대한 답을 고민해 보면서, 코드를 작성할 때 발생할 수 있는 구체적인 문제들과 해결책에 대해 미리 생각할 수 있을 겁니다.

1. 비동기 I/O와 콜백 헬(Callback Hell)
   질문: Node.js의 net 모듈은 비동기적으로 동작합니다. socket.on('data', ...)나 socket.on('end', ...) 같은 이벤트 핸들러(콜백 함수)를 사용하면 코드가 중첩되거나 복잡해질 수 있습니다. 이러한 **콜백 헬(Callback Hell)**을 방지하고 코드를 더 깔끔하게 관리할 수 있는 방법에는 무엇이 있을까요?

힌트: ES6에서 도입된 Promise나 async/await 문법을 활용하여 비동기 코드를 동기 코드처럼 읽기 쉽게 만들 수 있습니다.

2. MD 클라이언트 인증(Authentication)과 토큰
   질문: MD 클라이언트 인증 시 "서버와 클라이언트만 알고 있는 해시 함수를 활용"하라는 요구사항이 있습니다. 이 때 crypto 모듈을 사용해서 해시 함수를 구현할 수 있는데, 클라이언트가 보내는 토큰과 서버가 생성한 토큰을 비교할 때 단순히 문자열이 같은지 확인하는 것 외에 더 고려해야 할 점이 있을까요?

힌트: HMAC(Hash-based Message Authentication Code)는 비밀키를 이용해 메시지의 무결성과 인증을 동시에 보장하는 기술입니다. 클라이언트가 메시지와 함께 HMAC을 생성하여 보내면, 서버도 같은 비밀키로 HMAC을 생성하여 비교할 수 있습니다.

3. UDP 브로드캐스트와 클라이언트의 bind()
   질문: UDP 클라이언트에서 client.bind(PORT, HOST)와 client.bind(0, HOST)의 차이점은 무엇일까요? MD 클라이언트의 브로드캐스트 메시지를 수신하려면 어떤 방식으로 바인딩하는 것이 가장 적합할까요?

힌트: 0번 포트로 바인딩하면 운영체제가 사용 가능한 임시 포트를 자동으로 할당해줍니다. 특정 포트로 바인딩하면 그 포트에서만 수신 대기가 가능합니다.

4. TCP 소켓의 생명주기(Lifecycle)
   질문: net 모듈의 소켓은 여러 상태를 가집니다. socket.on('end', ...)와 socket.on('close', ...) 이벤트는 어떤 차이가 있을까요? 특히 클라이언트가 정상적으로 logout한 경우와 네트워크 오류로 갑자기 연결이 끊긴 경우를 구분해서 처리하려면 어떤 방법을 사용하는 것이 좋을까요?

힌트: end 이벤트는 소켓의 **수신 측(receiving side)**이 끊겼을 때 발생하고, close 이벤트는 소켓이 완전히 닫혔을 때 발생합니다. close 이벤트의 두 번째 인자인 hadError를 활용하면 오류로 인해 연결이 끊겼는지 여부를 파악할 수 있습니다.

이 질문들에 대한 답을 고민해보면서 미션의 구체적인 구현 방안을 더 탄탄하게 다질 수 있을 겁니다. 어떤 질문에 대해 먼저 답변해 보시겠어요?

</div>
</details>

- **J074\_김채영: Q3. 회고시 AI를 활용해보기**

  **이유**

  평소 데일리 회고나 주간 회고를 작성해왔습니다. 이를 AI를 통해 생각과 감정을 정리하면 어떤 방식으로 회고가 작성될지 궁금했고, 이 기회를 통해 AI에게 솔직하게 떠오르는 생각과 감정을 털어놓고 싶다는 마음이 들기도 해서 선택하게 되었습니다. AI와 함께 작성하는 이번 회고가 기대됩니다!

- **J248\_정희재 :Q1. 학습전 배겅지식 점검하기**

  **이유**

  미션을 진행할 때 학습 키워드와 배경 지식을 바탕으로 제가 모르는 부분과 모르는 것, 그리고 알고 있다고 생각한 것을 분리하며 학습계획을 정하고 이를 토대로 체크포인트를 작성했는데, AI에게 질문을 만들어달라고 한 뒤 스스로 체크하는 것도 좋은 방향이라고 생각했습니다. 보다 정확하게 저 자신을 파악할 수 있을 것 같아 선택했습니다.

  
<details>
<div markdown="1">
  <summary>진행한 퀘스트</summary>

  1. HTTP Request와 Response

- **Q1-1.** HTTP Request 메시지의 세 가지 주요 구성 요소는 무엇이며, 각 부분은 어떤 역할을 하나요?
    - 시작 줄, 헤더, body이고 각각 시작 줄은HTTP 요청의 의도, 리소스의 url HTTP 버전,  Header는 요청에 대한 메타데이터를 담고, 본문에는 실제로 전송할 데이터를 담아
- **Q1-2.** HTTP 응답 상태 코드 `200`, `404`, `500`의 차이점은 무엇이며, 각각 어떤 상황에 사용되나요?
    - 200 : 성공, 404 : Not Found, 500 : 5xx 범위의 오류

### **2. TCP / UDP / IP**

- **Q2-1.** TCP가 신뢰성 있는 데이터 전송을 보장하기 위해 사용하는 가장 중요한 두 가지 메커니즘
    - 3-way-handshake와 4-way-handshake
- **Q2-2.** TCP와 UDP 중, 실시간 영상 스트리밍에 더 적합한 프로토콜은 무엇이며 그 이유는 무엇인가요?
    - UDP. 데이터를 지연 없이 바로바로 보내기에 실시간 스트리밍에 적합함.
- **Q2-3.** IP의 가장 핵심적인 역할은 무엇이며, 왜 IP 자체만으로는 신뢰성을 보장할 수 없다고 하나요?

### **3. Echo Server**

- **Q3.** 에코 서버의 유일한 기능은 무엇이며, 네트워크 프로그래밍 학습에서 'Hello, World!'와 같은 역할을 하는 이유는 무엇인가요?
    - 전송한 요청 메세지를 그대로 응답 메세지로 받는 기능. 서버와 클라이언트의 연결을 확인할 수 있는 가장 기초적인 단계이기에?

### **4. Client와 Server**

- **Q4-1.** 클라이언트와 서버의 가장 근본적인 역할 차이는 무엇이며, 통신은 항상 어느 쪽에서 먼저 시작하나요?
    - ‘서비스를 제공하는 쪽’과 ‘서비스를 받는 쪽’. 통신은 항상 클라이언트에서 능동적으로 시작한다.
- **Q4-2.** 서버 프로그램이 반드시 가져야 하는 두 가지 핵심 정보는 무엇인가요? (힌트: 주소)
    - 주소와 포트

### **5. Session과 Connection**

- **Q5-1.** Connection과 Session은 OSI 7계층 중 각각 어느 계층에서 주로 다루어지는 개념인가요?
    - connection은 전송계층, session은 세션 계층. connection은 데이터 ‘전송’과 관련된 개념이고, 세션은 ‘상태’와 관련된 개념이다.
- **Q5-2.** "로그인 상태 유지"는 Connection과 Session 중 어느 것과 더 밀접한 관련이 있으며, 그 이유는 무엇인가요?
    - 로그인 ‘상태’ 유지는 세션과 더 관련되어 있다. (로그인이 일단 ‘되면’ connection은 그 후에 연결이 끊길때까진 별 일을 하지 않음)

### **6. JSON**

- **Q6-1.** JSON(JavaScript Object Notation)이 XML에 비해 가지는 두 가지 주요 장점은 무엇인가요?
    - 간결하고 편리함. JS에서 호환성이 뛰어남
- **Q6-2.** JavaScript에서 JSON 문자열을 객체로 변환하는 메서드와, 객체를 JSON 문자열로 변환하는 메서드는 각각 무엇인가요?
    - JSON → 객체는 JSON.parse(), 객체 → JSON은 JSON.stringify()

### **7. Unicast / Broadcast / Multicast**
- **Q7-1.** 1:1 화상 통화, 전체 공지 이메일, 온라인 게임 내의 팀 채팅은 각각 유니캐스트, 브로드캐스트, 멀티캐스트 중 어떤 방식에 해당하나요?
    - 1:1 방식은 유니캐스트, 전체 공지 이메일은 브로드캐스트(1:전체), 팀 채팅은 멀티캐스트 (1:그룹)
- **Q7-2.** 브로드캐스트 통신을 할 때 사용되는 특별한 IP 주소의 예시는 무엇이며, 왜 일반적인 인터넷 환경에서는 브로드캐스트가 제한되나요?
    - 255.255.255.255
    - 동일 네트워크에 모든 호스트에게 패킷 전송. 브로드캐스트가 제한되는 이유는 트래픽이 너무 크기 때문에? (네트워크 내 모든 호스트에게 전송해야 해서)
 
 이번 퀘스트를 진행하면서 제가 확실하게 학습한 부분과 부족한 부분을 알 수 있었고, 문제를 하나씩 풀어낼 때마다 성취감이 꽤 커서 스스로에게 동기부여가 되기도 했습니다.
 스스로 얼마나 학습을 진행했는지 잘 알 수 있으니 계획을 세우기도 한층 편했고, 체크포인트에도 생각하지 못했던 포인트들을 추가하는 등 도움이 생각보다 도움이 되어서 퀘스트 진행이 재밌었습니다.
 

</details>


- **K027\_천민재 :Q4. AI 사용에 대한 회고**

  **이유**

  무분별한 AI 사용에 대해서 경계하고 있고, 계속해서 그 답을 찾고 있는 과정 중에 있어 도움이 될 것 같아 선택하였습니다. 이번 퀘스트로 그 답을 찾을 수 있으면 좋을 것 같네요.
